from constants import *
import numpy as np

"""a simple library for spline interpolation through state space
used for interpolation of control points in MPC"""

def next_guide_point(guide_state, y0, x_goal, v_goal, turn_r):
    """a function to generate the next idealised state given a current state
    function takes the form x[k+1] = f(x[k])
    the trajectory states generated by this funciton are used as the basis for the optimisation
    in the MPC controller.

    Parameters:
    -----------
    guide_state (ndarray): the current state of the guide trajectory x[k]

    Returns:
    --------
    next_guide_state (ndarray): the next state of the guide trajectory x[k+1]
    """
    omega_goal = v_goal / turn_r
    x, y, psi, v, delta = guide_state
    if x < x_goal - turn_r:  # before turn
        next_state = [x + v_goal * DT,
                      y0, 
                      0,
                      v_goal,
                      0,]
    elif x >= x_goal - turn_r and y < y0 + turn_r:    # during turn
        #theta = np.atan((x + K - XG)/(y - Y0))
        theta = np.atan2(x + turn_r - x_goal, turn_r - (y + y0))
        next_theta = theta + omega_goal * DT

        next_state = [x_goal + turn_r*(np.sin(next_theta) - 1),
                      y0 + turn_r*(1 - np.cos(next_theta)),
                      next_theta,
                      v_goal, 
                      np.asin(1 / turn_r)]
    elif y >= y0 + turn_r:   # after turn
        next_state = [x_goal,
                      y + v_goal * DT,
                      np.pi / 2,
                      v_goal,
                      0]
    return np.array(next_state)

def generate_guide_trajectory(state, y0, x_goal, v_goal, turn_r):
    """a function to generate a guide trajectory for the mpc controller
    this function makes repeated calls to next_guide_point to construct a guide trajectory over
    the full solution horizon for the MPC to optimise to. 
    """
    trajectory = []
    for n in range(N):
        state = next_guide_point(state, y0, x_goal, v_goal, turn_r)
        trajectory.extend(state)
    return trajectory

if __name__ == "__main__":
    import matplotlib.pyplot as plt 
    y0, x_goal, v_goal, turn_r = 0, 100, 4, 15

    state = [90, 
             0, 
             0, 
             5, 
             0]
    
    trajectory = np.array(generate_guide_trajectory(state, y0, x_goal, v_goal, turn_r))
    trajectory = trajectory.reshape((N, NX))
    fig, ax = plt.subplots()
    ax.scatter(trajectory[:, 0], trajectory[:, 1])
    ax.set(aspect="equal")